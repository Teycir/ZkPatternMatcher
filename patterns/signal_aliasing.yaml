patterns:
  # Pattern: Component input aliasing - same signal wired to multiple ports
  # Detects: comp.a <== val; ... comp.b <== val; (within ~5 lines)
  - id: component_input_aliasing
    kind: regex
    pattern: '\w+\.\w+\s*<==\s*(\w+)\s*;[\s\S]{0,200}\w+\.\w+\s*<==\s*\1\s*;'
    message: >
      HIGH: The same signal appears to be wired to multiple component inputs.
      Verify these inputs are intentionally aliased. If they should be
      independent witnesses, this is a signal aliasing vulnerability that
      collapses the proof's degrees of freedom.
    severity: high

  # Pattern: Intermediate array signals assigned without unique constraints
  # Detects: intermediate[i] <-- (common in Merkle path circuits)
  - id: intermediate_array_unconstrained
    kind: regex
    pattern: 'intermediate\[\d+\]\s*<--'
    message: >
      MEDIUM: Intermediate array element assigned with <-- (unconstrained).
      In Merkle path circuits, intermediate values must be constrained to
      prevent path forgery. Verify each intermediate[i] has a corresponding
      constraint equation.
    severity: medium

invariants:
  - name: no_signal_aliasing
    invariant_type: constraint
    relation: "distinct_signals_for_independent_inputs"
    oracle: must_hold
    severity: high
    description: "Component inputs designed for independent witnesses must not be aliased"
