patterns:
  # Pattern 1: Path direction bit without binary constraint
  - id: unconstrained_path_direction
    kind: regex
    pattern: '\b(?:pathIndices|direction|pathIndex|side)\s*\[\s*\w+\s*\]\s*<--'
    message: >
      CRITICAL: Merkle path direction bit assigned with <-- (unconstrained).
      If pathIndices[i] is not constrained to {0,1}, a prover can supply
      non-binary direction bits, allowing traversal of non-existent paths
      and forging membership proofs. Constrain with:
        pathIndices[i] * (pathIndices[i] - 1) === 0;
    severity: critical

  # Pattern 2: MerkleTreeChecker or MerkleProof component (positive detection)
  - id: merkle_component_present
    kind: regex
    pattern: 'component\s+\w+\s*=\s*(?:MerkleTreeChecker|MerkleProof|MerklePathCheck|CheckMerkle)\s*\('
    message: >
      INFO: Merkle proof component detected. Verify: (1) path direction bits
      are binary-constrained, (2) leaf preimage is domain-separated from
      internal nodes, (3) computed root is constrained to equal the public
      root signal.
    severity: info

  # Pattern 3: Root comparison using == instead of ===
  - id: merkle_root_comparison_not_constraint
    kind: regex
    pattern: '\b(?:root|merkleRoot|computedRoot)\s*==\s*\w+(?:\[[^\]]+\])?|\b\w+(?:\[[^\]]+\])?\s*==\s*(?:root|merkleRoot|computedRoot)\b'
    message: >
      CRITICAL: Merkle root compared with == (boolean comparison) instead of
      === (circuit constraint). The == operator does not add any constraint â€”
      a prover can produce a proof with any root value. Replace with:
        computedRoot === publicRoot;
    severity: critical

  # Pattern 4: Selectors pattern (correct mux for left/right child)
  - id: merkle_selector_mux
    kind: regex
    pattern: '<==\s*\w+\s*\*\s*\w+\s*\+\s*\(\s*1\s*-\s*\w+\s*\)\s*\*\s*\w+'
    message: >
      INFO: Mux selector pattern detected (b*left + (1-b)*right). This is
      the standard Merkle path selector. Ensure the selector signal 'b'
      (typically pathIndices[i]) is binary-constrained.
    severity: info

  # Pattern 5: Leaf domain separation check
  - id: no_leaf_domain_separation
    kind: regex
    pattern: '(?:Poseidon|MiMC|Pedersen)\s*\(\s*1\s*\)'
    message: >
      MEDIUM: Hash component instantiated with a single input. In Merkle
      trees, leaves and internal nodes must be domain-separated (e.g., by
      prepending a type tag: leaf = Hash(0 || value), node = Hash(1 || l || r)).
      Without domain separation, a prover can substitute an internal node
      hash as a leaf, enabling second-preimage attacks.
    severity: medium

invariants:
  - name: path_bits_binary
    invariant_type: constraint
    relation: "path_direction_bit_in_zero_one"
    oracle: must_hold
    severity: critical
    description: "All Merkle path direction bits must be constrained to {0,1}"

  - name: root_is_constrained
    invariant_type: constraint
    relation: "computed_root_equals_public_root"
    oracle: must_hold
    severity: critical
    description: "The computed Merkle root must be constrained equal to the public root signal"
